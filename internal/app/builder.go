package app

import (
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/gizzahub/gzh-cli-shellforge/internal/domain"
)

// ManifestParser defines the interface for parsing YAML manifests.
type ManifestParser interface {
	Parse(path string) (*domain.Manifest, error)
}

// FileReader defines the interface for reading files.
type FileReader interface {
	ReadFile(path string) (string, error)
	FileExists(path string) bool
}

// FileWriter defines the interface for writing files.
type FileWriter interface {
	WriteFile(path string, content string) error
}

// BuilderService implements the build use case.
type BuilderService struct {
	manifestParser ManifestParser
	fileReader     FileReader
	fileWriter     FileWriter
	resolver       *domain.Resolver
}

// NewBuilderService creates a new builder service.
func NewBuilderService(parser ManifestParser, reader FileReader, writer FileWriter) *BuilderService {
	return &BuilderService{
		manifestParser: parser,
		fileReader:     reader,
		fileWriter:     writer,
		resolver:       domain.NewResolver(),
	}
}

// BuildOptions contains options for building shell configuration.
type BuildOptions struct {
	ConfigDir string // Directory containing module files
	Manifest  string // Path to manifest.yaml
	Output    string // Output file path
	OS        string // Target OS (Mac, Linux, etc.)
	DryRun    bool   // If true, don't write output file
	Verbose   bool   // Show detailed output
}

// BuildResult contains the result of a build operation.
type BuildResult struct {
	Output       string   // Generated shell configuration
	ModuleCount  int      // Number of modules included
	ModuleNames  []string // Names of modules in load order
	GeneratedAt  time.Time
}

// Build generates shell configuration from modules.
func (s *BuilderService) Build(opts BuildOptions) (*BuildResult, error) {
	// 1. Parse manifest
	manifest, err := s.manifestParser.Parse(opts.Manifest)
	if err != nil {
		return nil, fmt.Errorf("failed to parse manifest: %w", err)
	}

	// 2. Build dependency graph
	graph, err := s.resolver.BuildGraph(manifest)
	if err != nil {
		return nil, fmt.Errorf("failed to build dependency graph: %w", err)
	}

	// 3. Topological sort with OS filtering
	modules, err := s.resolver.TopologicalSort(graph, opts.OS)
	if err != nil {
		return nil, fmt.Errorf("failed to resolve dependencies: %w", err)
	}

	// 4. Read and concatenate module files
	var lines []string

	// Header
	now := time.Now()
	lines = append(lines, "# Generated by shellforge")
	lines = append(lines, fmt.Sprintf("# OS: %s", opts.OS))
	lines = append(lines, fmt.Sprintf("# Modules: %d", len(modules)))
	lines = append(lines, fmt.Sprintf("# Generated at: %s", now.Format(time.RFC3339)))
	lines = append(lines, "")

	// Module names for result
	moduleNames := make([]string, 0, len(modules))

	for _, module := range modules {
		moduleNames = append(moduleNames, module.Name)

		// Construct full path
		filePath := filepath.Join(opts.ConfigDir, module.File)

		// Check if file exists
		if !s.fileReader.FileExists(filePath) {
			return nil, domain.NewFileNotFoundError(filePath)
		}

		// Read module content
		content, err := s.fileReader.ReadFile(filePath)
		if err != nil {
			return nil, fmt.Errorf("failed to read module %s (%s): %w", module.Name, filePath, err)
		}

		// Add module header
		lines = append(lines, "")
		lines = append(lines, fmt.Sprintf("# --- %s ---", module.Name))
		if module.Description != "" {
			lines = append(lines, fmt.Sprintf("# %s", module.Description))
		}

		// Add module content (trim trailing whitespace)
		lines = append(lines, strings.TrimRight(content, " \t\n"))
		lines = append(lines, "")
	}

	output := strings.Join(lines, "\n")

	// 5. Write output (unless dry-run)
	if !opts.DryRun && opts.Output != "" {
		if err := s.fileWriter.WriteFile(opts.Output, output); err != nil {
			return nil, fmt.Errorf("failed to write output: %w", err)
		}
	}

	return &BuildResult{
		Output:       output,
		ModuleCount:  len(modules),
		ModuleNames:  moduleNames,
		GeneratedAt:  now,
	}, nil
}
