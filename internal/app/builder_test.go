package app

import (
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/gizzahub/gzh-cli-shellforge/internal/infra/filesystem"
	"github.com/gizzahub/gzh-cli-shellforge/internal/infra/yamlparser"
)

func TestBuilderService_Build(t *testing.T) {
	tests := []struct {
		name     string
		setup    func(afero.Fs)
		opts     BuildOptions
		wantErr  bool
		errMsg   string
		validate func(*testing.T, *BuildResult)
	}{
		{
			name: "simple linear dependencies",
			setup: func(fs afero.Fs) {
				// Create manifest
				manifest := `modules:
  - name: a
    file: a.sh
    requires: []
    os: [Mac]
  - name: b
    file: b.sh
    requires: [a]
    os: [Mac]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0644)

				// Create module files
				afero.WriteFile(fs, "a.sh", []byte("echo a"), 0644)
				afero.WriteFile(fs, "b.sh", []byte("echo b"), 0644)
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				Output:    "output.sh",
				OS:        "Mac",
				DryRun:    false,
			},
			wantErr: false,
			validate: func(t *testing.T, result *BuildResult) {
				assert.Equal(t, 2, result.ModuleCount)
				assert.Equal(t, []string{"a", "b"}, result.ModuleNames)
				assert.Contains(t, result.Output, "# Generated by shellforge")
				assert.Contains(t, result.Output, "# OS: Mac")
				assert.Contains(t, result.Output, "# --- a ---")
				assert.Contains(t, result.Output, "# --- b ---")
				assert.Contains(t, result.Output, "echo a")
				assert.Contains(t, result.Output, "echo b")
			},
		},
		{
			name: "OS filtering",
			setup: func(fs afero.Fs) {
				manifest := `modules:
  - name: mac-only
    file: mac.sh
    os: [Mac]
  - name: linux-only
    file: linux.sh
    os: [Linux]
  - name: both
    file: both.sh
    os: [Mac, Linux]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0644)
				afero.WriteFile(fs, "mac.sh", []byte("# Mac"), 0644)
				afero.WriteFile(fs, "linux.sh", []byte("# Linux"), 0644)
				afero.WriteFile(fs, "both.sh", []byte("# Both"), 0644)
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				Output:    "",
				OS:        "Mac",
				DryRun:    true,
			},
			wantErr: false,
			validate: func(t *testing.T, result *BuildResult) {
				assert.Equal(t, 2, result.ModuleCount)
				assert.Contains(t, result.ModuleNames, "mac-only")
				assert.Contains(t, result.ModuleNames, "both")
				assert.NotContains(t, result.ModuleNames, "linux-only")
			},
		},
		{
			name: "dry run does not write file",
			setup: func(fs afero.Fs) {
				manifest := `modules:
  - name: test
    file: test.sh
    os: [Mac]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0644)
				afero.WriteFile(fs, "test.sh", []byte("echo test"), 0644)
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				Output:    "should-not-exist.sh",
				OS:        "Mac",
				DryRun:    true,
			},
			wantErr: false,
			validate: func(t *testing.T, result *BuildResult) {
				assert.NotEmpty(t, result.Output)
			},
		},
		{
			name: "missing module file shows placeholder",
			setup: func(fs afero.Fs) {
				manifest := `modules:
  - name: missing
    file: missing.sh
    os: [Mac]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0644)
				// Don't create missing.sh
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				Output:    "output.sh",
				OS:        "Mac",
			},
			wantErr: false,
			validate: func(t *testing.T, result *BuildResult) {
				assert.Equal(t, 1, result.ModuleCount)
				assert.Contains(t, result.Output, "FILE NOT FOUND")
				assert.Contains(t, result.Output, "missing")
			},
		},
		{
			name: "circular dependency",
			setup: func(fs afero.Fs) {
				manifest := `modules:
  - name: a
    file: a.sh
    requires: [b]
    os: [Mac]
  - name: b
    file: b.sh
    requires: [a]
    os: [Mac]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0644)
				afero.WriteFile(fs, "a.sh", []byte("echo a"), 0644)
				afero.WriteFile(fs, "b.sh", []byte("echo b"), 0644)
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				Output:    "output.sh",
				OS:        "Mac",
			},
			wantErr: true,
			errMsg:  "circular dependency",
		},
		{
			name: "module with description",
			setup: func(fs afero.Fs) {
				manifest := `modules:
  - name: documented
    file: doc.sh
    description: This is a test module
    os: [Mac]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0644)
				afero.WriteFile(fs, "doc.sh", []byte("echo documented"), 0644)
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				OS:        "Mac",
				DryRun:    true,
			},
			wantErr: false,
			validate: func(t *testing.T, result *BuildResult) {
				assert.Contains(t, result.Output, "# This is a test module")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup in-memory filesystem
			fs := afero.NewMemMapFs()
			tt.setup(fs)

			// Create services
			parser := yamlparser.New(fs)
			reader := filesystem.NewReader(fs)
			writer := filesystem.NewWriter(fs)
			builder := NewBuilderService(parser, reader, writer)

			// Build
			result, err := builder.Build(tt.opts)

			if tt.wantErr {
				assert.Error(t, err)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), tt.errMsg)
				}
			} else {
				require.NoError(t, err)
				require.NotNil(t, result)

				// Verify output was written (if not dry-run)
				if !tt.opts.DryRun && tt.opts.Output != "" {
					exists, err := afero.Exists(fs, tt.opts.Output)
					require.NoError(t, err)
					assert.True(t, exists, "output file should exist")

					// Verify content matches result
					content, err := afero.ReadFile(fs, tt.opts.Output)
					require.NoError(t, err)
					assert.Equal(t, result.Output, string(content))
				}

				// Verify dry-run does not write file
				if tt.opts.DryRun && tt.opts.Output != "" {
					exists, _ := afero.Exists(fs, tt.opts.Output)
					assert.False(t, exists, "dry-run should not create file")
				}

				if tt.validate != nil {
					tt.validate(t, result)
				}
			}
		})
	}
}

// TestBuilderService_Build_RealExample tests with actual example files
func TestBuilderService_Build_RealExample(t *testing.T) {
	// Test with real filesystem
	fs := afero.NewOsFs()
	reader := filesystem.NewReader(fs)

	// Check if examples exist
	if !reader.FileExists("../../examples/manifest.yaml") {
		t.Skip("Example files not found, skipping")
	}

	// Create services with mixed filesystems
	osFs := afero.NewOsFs()
	parser := yamlparser.New(osFs)
	tmpFs := afero.NewMemMapFs() // Use in-memory for output
	writer := filesystem.NewWriter(tmpFs)
	builder := NewBuilderService(parser, reader, writer)

	// Build for Mac
	result, err := builder.Build(BuildOptions{
		ConfigDir: "../../examples/modules",
		Manifest:  "../../examples/manifest.yaml",
		Output:    "test-output.sh",
		OS:        "Mac",
		DryRun:    false,
	})

	require.NoError(t, err)
	require.NotNil(t, result)

	// Verify expected modules
	assert.Greater(t, result.ModuleCount, 5)
	assert.Contains(t, result.ModuleNames, "os-detection")
	assert.Contains(t, result.ModuleNames, "brew-path")

	// Verify output structure
	assert.Contains(t, result.Output, "# Generated by shellforge")
	assert.Contains(t, result.Output, "# OS: Mac")
	assert.Contains(t, result.Output, "#!/bin/bash")

	// Verify file was written
	content, err := afero.ReadFile(tmpFs, "test-output.sh")
	require.NoError(t, err)
	assert.Equal(t, result.Output, string(content))
}
