package app

import (
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/gizzahub/gzh-cli-shellforge/internal/infra/filesystem"
	"github.com/gizzahub/gzh-cli-shellforge/internal/infra/yamlparser"
)

func TestBuilderService_Build(t *testing.T) {
	tests := []struct {
		name     string
		setup    func(afero.Fs)
		opts     BuildOptions
		wantErr  bool
		errMsg   string
		validate func(*testing.T, *BuildResult, afero.Fs)
	}{
		{
			name: "simple linear dependencies",
			setup: func(fs afero.Fs) {
				// Create manifest
				manifest := `modules:
  - name: a
    file: a.sh
    requires: []
    os: [Mac]
  - name: b
    file: b.sh
    requires: [a]
    os: [Mac]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0o644)

				// Create module files
				afero.WriteFile(fs, "a.sh", []byte("echo a"), 0o644)
				afero.WriteFile(fs, "b.sh", []byte("echo b"), 0o644)
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				OutputDir: "./build",
				OS:        "Mac",
				DryRun:    false,
			},
			wantErr: false,
			validate: func(t *testing.T, result *BuildResult, fs afero.Fs) {
				assert.Equal(t, 2, result.TotalModuleCount)
				require.Len(t, result.Targets, 1)
				target := result.Targets[0]
				assert.Equal(t, []string{"a", "b"}, target.ModuleNames)
				assert.Contains(t, target.Content, "# Generated by shellforge")
				assert.Contains(t, target.Content, "# OS: Mac")
				assert.Contains(t, target.Content, "# --- a ---")
				assert.Contains(t, target.Content, "# --- b ---")
				assert.Contains(t, target.Content, "echo a")
				assert.Contains(t, target.Content, "echo b")
			},
		},
		{
			name: "OS filtering",
			setup: func(fs afero.Fs) {
				manifest := `modules:
  - name: mac-only
    file: mac.sh
    os: [Mac]
  - name: linux-only
    file: linux.sh
    os: [Linux]
  - name: both
    file: both.sh
    os: [Mac, Linux]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0o644)
				afero.WriteFile(fs, "mac.sh", []byte("# Mac"), 0o644)
				afero.WriteFile(fs, "linux.sh", []byte("# Linux"), 0o644)
				afero.WriteFile(fs, "both.sh", []byte("# Both"), 0o644)
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				OutputDir: "./build",
				OS:        "Mac",
				DryRun:    true,
			},
			wantErr: false,
			validate: func(t *testing.T, result *BuildResult, fs afero.Fs) {
				assert.Equal(t, 2, result.TotalModuleCount)
				// Collect all module names across targets
				var allModuleNames []string
				for _, target := range result.Targets {
					allModuleNames = append(allModuleNames, target.ModuleNames...)
				}
				assert.Contains(t, allModuleNames, "mac-only")
				assert.Contains(t, allModuleNames, "both")
				assert.NotContains(t, allModuleNames, "linux-only")
			},
		},
		{
			name: "dry run does not write file",
			setup: func(fs afero.Fs) {
				manifest := `modules:
  - name: test
    file: test.sh
    os: [Mac]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0o644)
				afero.WriteFile(fs, "test.sh", []byte("echo test"), 0o644)
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				OutputDir: "./should-not-exist",
				OS:        "Mac",
				DryRun:    true,
			},
			wantErr: false,
			validate: func(t *testing.T, result *BuildResult, fs afero.Fs) {
				require.Len(t, result.Targets, 1)
				assert.NotEmpty(t, result.Targets[0].Content)
				// Verify directory was not created
				exists, _ := afero.DirExists(fs, "./should-not-exist")
				assert.False(t, exists, "dry-run should not create directory")
			},
		},
		{
			name: "missing module file shows placeholder",
			setup: func(fs afero.Fs) {
				manifest := `modules:
  - name: missing
    file: missing.sh
    os: [Mac]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0o644)
				// Don't create missing.sh
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				OutputDir: "./build",
				OS:        "Mac",
			},
			wantErr: false,
			validate: func(t *testing.T, result *BuildResult, fs afero.Fs) {
				assert.Equal(t, 1, result.TotalModuleCount)
				require.Len(t, result.Targets, 1)
				assert.Contains(t, result.Targets[0].Content, "FILE NOT FOUND")
				assert.Contains(t, result.Targets[0].Content, "missing")
			},
		},
		{
			name: "circular dependency",
			setup: func(fs afero.Fs) {
				manifest := `modules:
  - name: a
    file: a.sh
    requires: [b]
    os: [Mac]
  - name: b
    file: b.sh
    requires: [a]
    os: [Mac]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0o644)
				afero.WriteFile(fs, "a.sh", []byte("echo a"), 0o644)
				afero.WriteFile(fs, "b.sh", []byte("echo b"), 0o644)
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				OutputDir: "./build",
				OS:        "Mac",
			},
			wantErr: true,
			errMsg:  "circular dependency",
		},
		{
			name: "module with description",
			setup: func(fs afero.Fs) {
				manifest := `modules:
  - name: documented
    file: doc.sh
    description: This is a test module
    os: [Mac]
`
				afero.WriteFile(fs, "manifest.yaml", []byte(manifest), 0o644)
				afero.WriteFile(fs, "doc.sh", []byte("echo documented"), 0o644)
			},
			opts: BuildOptions{
				ConfigDir: ".",
				Manifest:  "manifest.yaml",
				OutputDir: "./build",
				OS:        "Mac",
				DryRun:    true,
			},
			wantErr: false,
			validate: func(t *testing.T, result *BuildResult, fs afero.Fs) {
				require.Len(t, result.Targets, 1)
				assert.Contains(t, result.Targets[0].Content, "# This is a test module")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup in-memory filesystem
			fs := afero.NewMemMapFs()
			tt.setup(fs)

			// Create services
			parser := yamlparser.New(fs)
			reader := filesystem.NewReader(fs)
			writer := filesystem.NewWriter(fs)
			builder := NewBuilderService(parser, reader, writer)

			// Build
			result, err := builder.Build(tt.opts)

			if tt.wantErr {
				assert.Error(t, err)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), tt.errMsg)
				}
			} else {
				require.NoError(t, err)
				require.NotNil(t, result)

				// Verify output was written (if not dry-run)
				if !tt.opts.DryRun && tt.opts.OutputDir != "" {
					for _, target := range result.Targets {
						exists, err := afero.Exists(fs, target.FilePath)
						require.NoError(t, err)
						assert.True(t, exists, "output file should exist: %s", target.FilePath)

						// Verify content matches result
						content, err := afero.ReadFile(fs, target.FilePath)
						require.NoError(t, err)
						assert.Equal(t, target.Content, string(content))
					}
				}

				if tt.validate != nil {
					tt.validate(t, result, fs)
				}
			}
		})
	}
}

// TestBuilderService_Build_RealExample tests with actual example files
func TestBuilderService_Build_RealExample(t *testing.T) {
	// Test with real filesystem
	fs := afero.NewOsFs()
	reader := filesystem.NewReader(fs)

	// Check if examples exist
	if !reader.FileExists("../../examples/manifest.yaml") {
		t.Skip("Example files not found, skipping")
	}

	// Create services with mixed filesystems
	osFs := afero.NewOsFs()
	parser := yamlparser.New(osFs)
	tmpFs := afero.NewMemMapFs() // Use in-memory for output
	writer := filesystem.NewWriter(tmpFs)
	builder := NewBuilderService(parser, reader, writer)

	// Build for Mac
	result, err := builder.Build(BuildOptions{
		ConfigDir: "../../examples/modules",
		Manifest:  "../../examples/manifest.yaml",
		OutputDir: "./build",
		OS:        "Mac",
		DryRun:    false,
	})

	require.NoError(t, err)
	require.NotNil(t, result)

	// Verify expected modules
	assert.Greater(t, result.TotalModuleCount, 5)
	// Collect all module names
	var allModuleNames []string
	for _, target := range result.Targets {
		allModuleNames = append(allModuleNames, target.ModuleNames...)
	}
	assert.Contains(t, allModuleNames, "os-detection")
	assert.Contains(t, allModuleNames, "brew-path")

	// Verify output structure
	require.NotEmpty(t, result.Targets)
	assert.Contains(t, result.Targets[0].Content, "# Generated by shellforge")
	assert.Contains(t, result.Targets[0].Content, "# OS: Mac")

	// Verify files were written
	for _, target := range result.Targets {
		content, err := afero.ReadFile(tmpFs, target.FilePath)
		require.NoError(t, err)
		assert.Equal(t, target.Content, string(content))
	}
}
