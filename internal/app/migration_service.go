package app

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/gizzahub/gzh-cli-shellforge/internal/domain"
)

// RCParser defines the interface for parsing RC files
type RCParser interface {
	ParseFile(path string) (*domain.MigrationResult, error)
}

// MigrationService handles migration of monolithic RC files to modular structure
type MigrationService struct {
	parser RCParser
	reader FileReader
	writer FileWriter
}

// NewMigrationService creates a new migration service
func NewMigrationService(parser RCParser, reader FileReader, writer FileWriter) *MigrationService {
	return &MigrationService{
		parser: parser,
		reader: reader,
		writer: writer,
	}
}

// MigrateResult contains the result of an RC file migration
type MigrateResult struct {
	SourceFile      string
	Sections        []domain.Section
	ModulesCreated  int
	ManifestPath    string
	Warnings        []string
	ModuleFilesPaths []string
}

// Analyze parses an RC file and returns detected sections without creating files
func (s *MigrationService) Analyze(rcFilePath string) (*MigrateResult, error) {
	// Use the parser to parse the RC file
	result, err := s.parser.ParseFile(rcFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to parse RC file: %w", err)
	}

	migrateResult := &MigrateResult{
		SourceFile:     rcFilePath,
		Sections:       result.Sections,
		ModulesCreated: len(result.Modules),
		Warnings:       result.Warnings,
	}

	return migrateResult, nil
}

// Migrate performs the full migration: analyze, create module files, and generate manifest
func (s *MigrationService) Migrate(rcFilePath, outputDir, manifestPath string) (*MigrateResult, error) {
	// Use the parser to parse the RC file
	result, err := s.parser.ParseFile(rcFilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to parse RC file: %w", err)
	}

	if len(result.Sections) == 0 {
		result.AddWarning("no sections detected in RC file - file may be unsegmented")
	}

	// Track created file paths
	modulePaths := make([]string, 0, len(result.Sections))

	// Create module files
	for i, section := range result.Sections {
		// Find corresponding module
		module := result.Modules[i]

		// Write module file
		fullPath := filepath.Join(outputDir, module.File)
		moduleContent := s.generateModuleContent(module, section.Content)

		if err := s.writer.WriteFile(fullPath, moduleContent); err != nil {
			return nil, fmt.Errorf("failed to write module file %s: %w", fullPath, err)
		}

		modulePaths = append(modulePaths, fullPath)
	}

	// Generate and write manifest
	manifestContent := s.generateManifestYAML(result.Manifest)

	if err := s.writer.WriteFile(manifestPath, manifestContent); err != nil {
		return nil, fmt.Errorf("failed to write manifest file: %w", err)
	}

	migrateResult := &MigrateResult{
		SourceFile:       rcFilePath,
		Sections:         result.Sections,
		ModulesCreated:   len(result.Modules),
		ManifestPath:     manifestPath,
		Warnings:         result.Warnings,
		ModuleFilesPaths: modulePaths,
	}

	return migrateResult, nil
}

// generateModuleContent creates the module file content with header
func (s *MigrationService) generateModuleContent(module domain.Module, content string) string {
	var sb strings.Builder

	// Module header
	sb.WriteString("#!/bin/bash\n")
	sb.WriteString(fmt.Sprintf("# Module: %s\n", module.Name))

	if module.Description != "" {
		sb.WriteString(fmt.Sprintf("# Description: %s\n", module.Description))
	}

	if len(module.Requires) > 0 {
		sb.WriteString(fmt.Sprintf("# Requires: %s\n", strings.Join(module.Requires, ", ")))
	}

	if len(module.OS) > 0 {
		sb.WriteString(fmt.Sprintf("# OS: %s\n", strings.Join(module.OS, ", ")))
	}

	sb.WriteString("\n")
	sb.WriteString(content)

	// Ensure file ends with newline
	if !strings.HasSuffix(content, "\n") {
		sb.WriteString("\n")
	}

	return sb.String()
}

// generateManifestYAML creates the YAML manifest content
func (s *MigrationService) generateManifestYAML(manifest *domain.Manifest) string {
	var sb strings.Builder

	sb.WriteString("# Generated by gz-shellforge migrate\n")
	sb.WriteString("modules:\n")

	for _, module := range manifest.Modules {
		sb.WriteString(fmt.Sprintf("  - name: %s\n", module.Name))
		sb.WriteString(fmt.Sprintf("    file: %s\n", module.File))

		if len(module.Requires) > 0 {
			sb.WriteString("    requires:\n")
			for _, dep := range module.Requires {
				sb.WriteString(fmt.Sprintf("      - %s\n", dep))
			}
		} else {
			sb.WriteString("    requires: []\n")
		}

		if len(module.OS) > 0 {
			sb.WriteString("    os:\n")
			for _, os := range module.OS {
				sb.WriteString(fmt.Sprintf("      - %s\n", os))
			}
		}

		if module.Description != "" {
			sb.WriteString(fmt.Sprintf("    description: %s\n", module.Description))
		}

		sb.WriteString("\n")
	}

	return sb.String()
}
