package cli

import (
	"bytes"
	"strings"
	"testing"

	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestBuildCmd_Flags(t *testing.T) {
	cmd := newBuildCmd()

	// Check required flags
	osFlag := cmd.Flags().Lookup("os")
	require.NotNil(t, osFlag)
	assert.Equal(t, "", osFlag.DefValue)

	// Check optional flags with defaults
	manifestFlag := cmd.Flags().Lookup("manifest")
	require.NotNil(t, manifestFlag)
	assert.Equal(t, "manifest.yaml", manifestFlag.DefValue)

	configDirFlag := cmd.Flags().Lookup("config-dir")
	require.NotNil(t, configDirFlag)
	assert.Equal(t, "modules", configDirFlag.DefValue)

	// Check v2 flags
	outputDirFlag := cmd.Flags().Lookup("output-dir")
	require.NotNil(t, outputDirFlag)
	assert.Equal(t, "", outputDirFlag.DefValue)

	shellFlag := cmd.Flags().Lookup("shell")
	require.NotNil(t, shellFlag)
	assert.Equal(t, "", shellFlag.DefValue)

	// Check legacy single-output flag
	singleOutputFlag := cmd.Flags().Lookup("single-output")
	require.NotNil(t, singleOutputFlag)
	assert.Equal(t, "", singleOutputFlag.DefValue)

	dryRunFlag := cmd.Flags().Lookup("dry-run")
	require.NotNil(t, dryRunFlag)
	assert.Equal(t, "false", dryRunFlag.DefValue)

	verboseFlag := cmd.Flags().Lookup("verbose")
	require.NotNil(t, verboseFlag)
	assert.Equal(t, "false", verboseFlag.DefValue)
}

func TestBuildCmd_Help(t *testing.T) {
	cmd := newBuildCmd()

	assert.Equal(t, "build", cmd.Use)
	assert.Contains(t, cmd.Short, "Build shell configuration")
	assert.Contains(t, cmd.Long, "topological")
	assert.NotEmpty(t, cmd.Example)
}

func TestRunBuild_ValidationErrors(t *testing.T) {
	tests := []struct {
		name    string
		flags   *buildFlags
		wantErr string
	}{
		{
			name: "missing output and not dry-run",
			flags: &buildFlags{
				targetOS:     "Mac",
				singleOutput: "",
				outputDir:    "",
				dryRun:       false,
			},
			wantErr: "output not specified",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := runBuild(tt.flags)
			assert.Error(t, err)
			assert.Contains(t, err.Error(), tt.wantErr)
		})
	}
}

func TestRunBuild_Success(t *testing.T) {
	// This is an integration-style test that uses real filesystem
	// Skip if examples directory doesn't exist
	fs := afero.NewOsFs()
	exists, _ := afero.Exists(fs, "../../examples/manifest.yaml")
	if !exists {
		t.Skip("Examples directory not found, skipping integration test")
	}

	tests := []struct {
		name         string
		flags        *buildFlags
		wantModules  int
		wantInOutput []string
	}{
		{
			name: "Mac build with dry-run",
			flags: &buildFlags{
				configDir:    "../../examples/modules",
				manifest:     "../../examples/manifest.yaml",
				singleOutput: "",
				targetOS:     "Mac",
				dryRun:       true,
				verbose:      false,
			},
			wantModules: 9,
			wantInOutput: []string{
				"# Generated by shellforge",
				"# OS: Mac",
				"os-detection",
				"brew-path",
			},
		},
		{
			name: "Linux build with dry-run",
			flags: &buildFlags{
				configDir:    "../../examples/modules",
				manifest:     "../../examples/manifest.yaml",
				singleOutput: "",
				targetOS:     "Linux",
				dryRun:       true,
				verbose:      false,
			},
			wantModules: 7,
			wantInOutput: []string{
				"# Generated by shellforge",
				"# OS: Linux",
				"os-detection",
				"pacman-setup",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Capture stdout
			var buf bytes.Buffer

			// Note: This test validates the runBuild function logic
			// In a real scenario, we'd need to mock the builder service
			// For now, we test that the function executes without error
			err := runBuild(tt.flags)

			// Should succeed with dry-run
			assert.NoError(t, err, "runBuild should succeed with valid flags")

			// Note: Full output validation would require capturing stdout
			// which is beyond the scope of unit tests
			// Integration tests would handle this
			_ = buf // Placeholder for future stdout capture
		})
	}
}

func TestBuildCmd_FlagShortcuts(t *testing.T) {
	cmd := newBuildCmd()

	// Test short flag versions
	tests := []struct {
		flag      string
		shorthand string
	}{
		{"config-dir", "c"},
		{"manifest", "m"},
		{"single-output", "o"},
		{"output-dir", "d"},
		{"shell", "s"},
		{"target", "t"},
		{"verbose", "v"},
	}

	for _, tt := range tests {
		t.Run(tt.flag, func(t *testing.T) {
			flag := cmd.Flags().Lookup(tt.flag)
			require.NotNil(t, flag)
			assert.Equal(t, tt.shorthand, flag.Shorthand)
		})
	}
}

func TestBuildCmd_Examples(t *testing.T) {
	cmd := newBuildCmd()

	// Verify example includes common use cases
	examples := cmd.Example

	assert.Contains(t, examples, "--os Mac", "should show Mac OS example")
	assert.Contains(t, examples, "--os Linux", "should show Linux example")
	assert.Contains(t, examples, "--dry-run", "should show dry-run example")
	assert.Contains(t, examples, "--output-dir", "should show output-dir example")
	assert.Contains(t, examples, "--single-output", "should show single-output example")
	assert.Contains(t, examples, "~/.zshrc", "should show output to home directory example")
	assert.Contains(t, examples, "--shell bash", "should show shell type example")
	assert.Contains(t, examples, "--target", "should show target filter example")
}

func TestBuildFlags_Validation(t *testing.T) {
	// Test various flag combinations
	tests := []struct {
		name    string
		flags   *buildFlags
		setup   func(*buildFlags)
		wantErr bool
	}{
		{
			name: "valid with single-output",
			setup: func(f *buildFlags) {
				f.targetOS = "Mac"
				f.singleOutput = "/tmp/test.sh"
				f.dryRun = false
			},
			wantErr: false,
		},
		{
			name: "valid with output-dir",
			setup: func(f *buildFlags) {
				f.targetOS = "Mac"
				f.outputDir = "/tmp"
				f.dryRun = false
			},
			wantErr: false,
		},
		{
			name: "valid with dry-run",
			setup: func(f *buildFlags) {
				f.targetOS = "Mac"
				f.singleOutput = ""
				f.outputDir = ""
				f.dryRun = true
			},
			wantErr: false,
		},
		{
			name: "invalid - no output and no dry-run",
			setup: func(f *buildFlags) {
				f.targetOS = "Mac"
				f.singleOutput = ""
				f.outputDir = ""
				f.dryRun = false
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			flags := &buildFlags{
				configDir: "modules",
				manifest:  "manifest.yaml",
			}
			tt.setup(flags)

			// We can only test the validation logic in runBuild
			// Since runBuild will fail on missing files, we just check
			// if it gets past the validation step
			err := runBuild(flags)

			if tt.wantErr {
				assert.Error(t, err)
			} else {
				// May error on missing files, which is fine
				// We're just checking flag validation passed
				_ = err
			}
		})
	}
}

func TestBuildCmd_UsageText(t *testing.T) {
	cmd := newBuildCmd()

	// Get usage text
	usage := cmd.UsageString()

	// Verify it contains key information
	assert.Contains(t, usage, "build", "usage should contain command name")
	assert.Contains(t, usage, "Flags:", "usage should list flags")
	assert.Contains(t, usage, "--os", "usage should show --os flag")
	assert.Contains(t, usage, "--manifest", "usage should show --manifest flag")
}

func TestBuildCmd_LongDescription(t *testing.T) {
	cmd := newBuildCmd()

	long := cmd.Long

	// Verify long description contains key concepts
	expectedTerms := []string{
		"manifest",
		"dependencies",
		"topological",
		"OS",
		"target",
		"multi-target",
		"legacy",
		"priority",
	}

	for _, term := range expectedTerms {
		assert.Contains(t, strings.ToLower(long), strings.ToLower(term),
			"long description should mention '%s'", term)
	}
}
