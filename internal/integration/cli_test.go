package integration

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// getBinaryPath returns the path to the gz-shellforge binary
func getBinaryPath(t *testing.T) string {
	t.Helper()

	// Try to find the binary in common locations
	paths := []string{
		"../../build/gz-shellforge",
		"./build/gz-shellforge",
		"gz-shellforge", // In PATH
	}

	for _, path := range paths {
		if _, err := os.Stat(path); err == nil {
			absPath, _ := filepath.Abs(path)
			return absPath
		}
		// Check if it's in PATH
		if path == "gz-shellforge" {
			if _, err := exec.LookPath("gz-shellforge"); err == nil {
				return "gz-shellforge"
			}
		}
	}

	// Build it if not found
	t.Log("Binary not found, building...")
	cmd := exec.Command("make", "build")
	cmd.Dir = "../.."
	if err := cmd.Run(); err != nil {
		t.Fatalf("Failed to build binary: %v", err)
	}

	absPath, _ := filepath.Abs("../../build/gz-shellforge")
	return absPath
}

// TestCLI_Version tests the --version flag
func TestCLI_Version(t *testing.T) {
	binary := getBinaryPath(t)

	cmd := exec.Command(binary, "--version")
	output, err := cmd.CombinedOutput()

	require.NoError(t, err, "Command should succeed")
	assert.Contains(t, string(output), "0.5.1", "Should show version number")
}

// TestCLI_Help tests the --help flag
func TestCLI_Help(t *testing.T) {
	binary := getBinaryPath(t)

	tests := []struct {
		name     string
		args     []string
		expected []string
	}{
		{
			name: "root help",
			args: []string{"--help"},
			expected: []string{
				"Shellforge is a build tool",
				"Available Commands:",
				"build",
				"validate",
				"migrate",
			},
		},
		{
			name: "build help",
			args: []string{"build", "--help"},
			expected: []string{
				"Build generates a shell configuration",
				"--manifest",
				"--config-dir",
				"--os",
				"--output",
			},
		},
		{
			name: "validate help",
			args: []string{"validate", "--help"},
			expected: []string{
				"Validate checks the manifest file",
				"--manifest",
				"--config-dir",
			},
		},
		{
			name: "migrate help",
			args: []string{"migrate", "--help"},
			expected: []string{
				"Migrate converts a monolithic shell",
				"--output-dir",
				"--manifest",
			},
		},
		{
			name: "diff help",
			args: []string{"diff", "--help"},
			expected: []string{
				"Compare two shell configuration files",
				"--format",
				"summary",
				"unified",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cmd := exec.Command(binary, tt.args...)
			output, err := cmd.CombinedOutput()

			require.NoError(t, err, "Help command should succeed")

			outputStr := string(output)
			for _, expected := range tt.expected {
				assert.Contains(t, outputStr, expected, "Help output should contain: %s", expected)
			}
		})
	}
}

// TestCLI_Build tests the build command with actual execution
func TestCLI_Build(t *testing.T) {
	binary := getBinaryPath(t)
	tempDir := t.TempDir()

	// Create test manifest
	manifestPath := filepath.Join(tempDir, "manifest.yaml")
	manifestContent := `modules:
  - name: test-module
    file: modules/test.sh
    description: Test module
    os: [Mac, Linux]
`
	require.NoError(t, os.WriteFile(manifestPath, []byte(manifestContent), 0644))

	// Create test module
	modulesDir := filepath.Join(tempDir, "modules")
	require.NoError(t, os.MkdirAll(modulesDir, 0755))
	moduleContent := `#!/bin/bash
# Test module
export TEST_VAR="test"
`
	modulePath := filepath.Join(modulesDir, "test.sh")
	require.NoError(t, os.WriteFile(modulePath, []byte(moduleContent), 0644))

	outputPath := filepath.Join(tempDir, "output.sh")

	// Test successful build
	t.Run("successful build", func(t *testing.T) {
		cmd := exec.Command(binary, "build",
			"--manifest", manifestPath,
			"--config-dir", tempDir,
			"--os", "Mac",
			"--output", outputPath,
		)
		output, err := cmd.CombinedOutput()

		require.NoError(t, err, "Build should succeed: %s", string(output))
		assert.Contains(t, string(output), "Configuration written to", "Should show success message")

		// Verify output file exists
		_, err = os.Stat(outputPath)
		require.NoError(t, err, "Output file should exist")

		// Verify output content
		content, err := os.ReadFile(outputPath)
		require.NoError(t, err)
		assert.Contains(t, string(content), "TEST_VAR", "Output should contain module content")
		assert.Contains(t, string(content), "Generated by shellforge", "Output should have header")
	})

	// Test dry-run
	t.Run("dry-run build", func(t *testing.T) {
		cmd := exec.Command(binary, "build",
			"--manifest", manifestPath,
			"--config-dir", tempDir,
			"--os", "Mac",
			"--dry-run",
		)
		output, err := cmd.CombinedOutput()

		require.NoError(t, err, "Dry-run should succeed")
		assert.Contains(t, string(output), "Generated by shellforge", "Should show output")
		assert.Contains(t, string(output), "TEST_VAR", "Should show module content")
	})

	// Test missing manifest error
	t.Run("missing manifest", func(t *testing.T) {
		cmd := exec.Command(binary, "build",
			"--manifest", "/nonexistent/manifest.yaml",
			"--config-dir", tempDir,
			"--os", "Mac",
		)
		output, err := cmd.CombinedOutput()

		assert.Error(t, err, "Should fail with error")
		assert.Contains(t, string(output), "Error", "Should show error message")
	})
}

// TestCLI_Validate tests the validate command
func TestCLI_Validate(t *testing.T) {
	binary := getBinaryPath(t)
	tempDir := t.TempDir()

	// Create valid manifest and module
	manifestPath := filepath.Join(tempDir, "manifest.yaml")
	manifestContent := `modules:
  - name: test-module
    file: modules/test.sh
    description: Test module
    os: [Mac, Linux]
`
	require.NoError(t, os.WriteFile(manifestPath, []byte(manifestContent), 0644))

	modulesDir := filepath.Join(tempDir, "modules")
	require.NoError(t, os.MkdirAll(modulesDir, 0755))
	moduleContent := "#!/bin/bash\necho 'test'\n"
	modulePath := filepath.Join(modulesDir, "test.sh")
	require.NoError(t, os.WriteFile(modulePath, []byte(moduleContent), 0644))

	t.Run("valid manifest", func(t *testing.T) {
		cmd := exec.Command(binary, "validate",
			"--manifest", manifestPath,
			"--config-dir", tempDir,
		)
		output, err := cmd.CombinedOutput()

		require.NoError(t, err, "Validation should succeed: %s", string(output))
		assert.Contains(t, string(output), "Validation successful", "Should show success message")
	})

	t.Run("missing module file", func(t *testing.T) {
		// Create manifest with non-existent module
		badManifest := filepath.Join(tempDir, "bad-manifest.yaml")
		badContent := `modules:
  - name: missing
    file: modules/missing.sh
    description: Missing module
`
		require.NoError(t, os.WriteFile(badManifest, []byte(badContent), 0644))

		cmd := exec.Command(binary, "validate",
			"--manifest", badManifest,
			"--config-dir", tempDir,
		)
		output, err := cmd.CombinedOutput()

		assert.Error(t, err, "Should fail validation")
		outputStr := string(output)
		assert.True(t,
			strings.Contains(outputStr, "Error") || strings.Contains(outputStr, "not found"),
			"Should show error about missing file: %s", outputStr)
	})
}

// TestCLI_Migrate tests the migrate command
func TestCLI_Migrate(t *testing.T) {
	binary := getBinaryPath(t)
	tempDir := t.TempDir()

	// Create sample RC file
	rcPath := filepath.Join(tempDir, ".zshrc")
	rcContent := `# Sample .zshrc
# === OS Detection ===
case "$(uname -s)" in
  Darwin) export MACHINE="Mac" ;;
  Linux) export MACHINE="Linux" ;;
esac

# --- PATH Setup ---
export PATH="/usr/local/bin:$PATH"

# --- Aliases ---
alias gs='git status'
`
	require.NoError(t, os.WriteFile(rcPath, []byte(rcContent), 0644))

	outputDir := filepath.Join(tempDir, "modules")
	manifestPath := filepath.Join(tempDir, "manifest.yaml")

	t.Run("successful migration", func(t *testing.T) {
		cmd := exec.Command(binary, "migrate", rcPath,
			"--output-dir", outputDir,
			"--manifest", manifestPath,
		)
		output, err := cmd.CombinedOutput()

		require.NoError(t, err, "Migration should succeed: %s", string(output))
		assert.Contains(t, string(output), "Migration Complete", "Should show success")

		// Verify manifest was created
		_, err = os.Stat(manifestPath)
		require.NoError(t, err, "Manifest should be created")

		// Verify modules directory was created
		_, err = os.Stat(outputDir)
		require.NoError(t, err, "Modules directory should be created")

		// Verify some module files were created
		entries, err := os.ReadDir(outputDir)
		require.NoError(t, err)

		// Check if there are subdirectories with modules
		hasModules := false
		for _, entry := range entries {
			if entry.IsDir() {
				subEntries, _ := os.ReadDir(filepath.Join(outputDir, entry.Name()))
				if len(subEntries) > 0 {
					hasModules = true
					break
				}
			}
		}
		assert.True(t, hasModules, "Should create module files")
	})

	t.Run("missing RC file", func(t *testing.T) {
		cmd := exec.Command(binary, "migrate", "/nonexistent/.zshrc",
			"--output-dir", filepath.Join(tempDir, "modules2"),
			"--manifest", filepath.Join(tempDir, "manifest2.yaml"),
		)
		output, err := cmd.CombinedOutput()

		assert.Error(t, err, "Should fail with missing file")
		outputStr := string(output)
		assert.True(t,
			strings.Contains(outputStr, "Error") || strings.Contains(outputStr, "not found") || strings.Contains(outputStr, "no such file"),
			"Should show error: %s", outputStr)
	})
}

// TestCLI_Diff tests the diff command
func TestCLI_Diff(t *testing.T) {
	binary := getBinaryPath(t)
	tempDir := t.TempDir()

	// Create two files to compare
	file1 := filepath.Join(tempDir, "file1.sh")
	file1Content := `#!/bin/bash
line1
line2
line3
`
	require.NoError(t, os.WriteFile(file1, []byte(file1Content), 0644))

	file2 := filepath.Join(tempDir, "file2.sh")
	file2Content := `#!/bin/bash
line1
line2_modified
line3
line4
`
	require.NoError(t, os.WriteFile(file2, []byte(file2Content), 0644))

	tests := []struct {
		name     string
		format   string
		expected []string
	}{
		{
			name:   "summary format",
			format: "summary",
			expected: []string{
				"Statistics:",
				"Added:",
				"Modified:",
			},
		},
		{
			name:   "unified format",
			format: "unified",
			expected: []string{
				"---",
				"+++",
				"-line2",
				"+line2_modified",
			},
		},
		{
			name:   "side-by-side format",
			format: "side-by-side",
			expected: []string{
				"file1.sh",
				"file2.sh",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.format, func(t *testing.T) {
			cmd := exec.Command(binary, "diff", file1, file2,
				"--format", tt.format,
			)
			output, err := cmd.CombinedOutput()

			require.NoError(t, err, "Diff should succeed: %s", string(output))

			outputStr := string(output)
			for _, expected := range tt.expected {
				assert.Contains(t, outputStr, expected, "Should contain: %s", expected)
			}
		})
	}

	t.Run("identical files", func(t *testing.T) {
		file3 := filepath.Join(tempDir, "file3.sh")
		require.NoError(t, os.WriteFile(file3, []byte(file1Content), 0644))

		cmd := exec.Command(binary, "diff", file1, file3, "--format", "summary")
		output, err := cmd.CombinedOutput()

		require.NoError(t, err, "Diff should succeed")
		assert.Contains(t, string(output), "identical", "Should indicate files are identical")
	})
}

// TestCLI_ExitCodes tests that commands return appropriate exit codes
func TestCLI_ExitCodes(t *testing.T) {
	binary := getBinaryPath(t)

	tests := []struct {
		name         string
		args         []string
		expectError  bool
		errorPattern string
	}{
		{
			name:        "successful version",
			args:        []string{"--version"},
			expectError: false,
		},
		{
			name:        "successful help",
			args:        []string{"--help"},
			expectError: false,
		},
		{
			name:         "invalid command",
			args:         []string{"nonexistent"},
			expectError:  true,
			errorPattern: "unknown command",
		},
		{
			name:         "build missing required flag",
			args:         []string{"build"},
			expectError:  true,
			errorPattern: "required flag",
		},
		{
			name:         "invalid flag",
			args:         []string{"build", "--invalid-flag"},
			expectError:  true,
			errorPattern: "unknown flag",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cmd := exec.Command(binary, tt.args...)
			output, err := cmd.CombinedOutput()

			if tt.expectError {
				assert.Error(t, err, "Command should fail")
				if tt.errorPattern != "" {
					outputStr := strings.ToLower(string(output))
					pattern := strings.ToLower(tt.errorPattern)
					assert.Contains(t, outputStr, pattern, "Error should match pattern: %s", tt.errorPattern)
				}
			} else {
				assert.NoError(t, err, "Command should succeed: %s", string(output))
			}
		})
	}
}
